#!/usr/bin/env node
import { analyzeTemplate, RuleSet } from "./analyzeTemplate.js";
import { mkdir, writeFile } from "fs/promises";
import { existsSync } from "fs";
import path from "path";
import dotenv from "dotenv";
import { generateDashboard } from "./dashboardGenerator.js";
import { openDashboard, serveDashboard } from "./dashboardServer.js";
import { createGitHubIssue, testAzdProvision, getAzdProvisionStatus, getGitHubIssues, updateGitHubIssue } from "./mcpClient.js";

dotenv.config();

const [,, command, ...args] = process.argv;

// Common argument parsing
const repoArg = args.find(a => a.startsWith("--repo="));
const repoUrl = repoArg?.split("=")[1];
const openDashboardFlag = args.includes("--open-dashboard");
const serveFlag = args.includes("--serve");
const portArg = args.find(a => a.startsWith("--port="));
const port = portArg ? parseInt(portArg.split("=")[1], 10) : 3000;
const createIssueFlag = args.includes("--create-issue");

// Parse rule set flag
const ruleSetArg = args.find(a => a.startsWith("--rules="));
const ruleSet = (ruleSetArg?.split("=")[1] as RuleSet) || "dod";

// Handle different commands
async function run() {
  // If no specific command is provided, use the default analyze command
  const resolvedCommand = command?.startsWith("--") ? "analyze" : command || "analyze";

  switch (resolvedCommand) {
    case "analyze":
      await analyzeCommand();
      break;
    case "create-issue":
      await createIssueCommand();
      break;
    case "provision":
      await provisionCommand();
      break;
    case "status":
      await statusCommand();
      break;
    case "list":
    case "templates":
      await listCommand();
      break;
    case "rebuild":
    case "update-index":
      await rebuildCommand();
      break;
    case "help":
    default:
      showHelp();
      break;
  }
}

function showHelp() {
  console.log("Template Doctor CLI");
  console.log("===================\n");
  console.log("Usage:");
  console.log("  template-doctor <command> [options]\n");
  console.log("Commands:");
  console.log("  analyze            Analyze a template repository (default)");
  console.log("  create-issue       Create a GitHub issue with analysis results");
  console.log("  provision          Start an AZD provision test");
  console.log("  status             Check the status of an AZD provision job");
  console.log("  list, templates    List all analyzed templates and open dashboard");
  console.log("  rebuild            Regenerate the template index dashboard");
  console.log("  help               Show this help message\n");
  console.log("Options:");
  console.log("  --repo=<url>       URL of the GitHub repository to analyze");
  console.log("  --serve            Start a local server to view the dashboard");
  console.log("  --open-dashboard   Open the dashboard in the default browser");
  console.log("  --port=<number>    Specify the port for the dashboard server (default: 3000)");
  console.log("  --create-issue     Automatically create a GitHub issue with results");
  console.log("  --job-id=<id>      Specify the job ID for the 'status' command");
  console.log("  --env=<env>        Specify the environment name for provisioning (default: 'dev')");
  console.log("  --rules=<type>     Specify the rule set to use: 'dod', 'partner', or 'custom' (default: 'dod')");
  process.exit(1);
}

async function analyzeCommand() {
  if (!repoUrl) {
    console.error("‚ùå Missing required argument: --repo=https://github.com/user/repo");
    showHelp();
    return;
  }
  
  // If openDashboardFlag is set, open the dashboard in the browser

  try {
    // Show which ruleset is being used
    console.log(`üîç Analyzing repository with rule set: ${ruleSet}`);
    const result = await analyzeTemplate(repoUrl, ruleSet);

    const resultsDir = path.resolve("results");
    if (!existsSync(resultsDir)) {
      await mkdir(resultsDir, { recursive: true });
    }
    const outputPath = path.resolve(resultsDir, `${Date.now()}-analysis.json`);
    await writeFile(outputPath, JSON.stringify(result, null, 2));
    console.log(`‚úÖ Analysis complete. Output saved to: ${outputPath}`);

    // Generate the dashboard
    const dashboardPath = await generateDashboard(result, outputPath);
    console.log(`üé® Dashboard generated at: ${dashboardPath}`);
    
    // If create issue flag is set, create a GitHub issue
    if (createIssueFlag) {
      await createIssueFromResults(result);
    }

    // Always make sure the index file is updated with the new template
    console.log("üîÑ Updating template index...");
    
    // Import the updateIndexFile function from dashboardGenerator
    const { updateIndexFile } = await import("./dashboardGenerator.js");
    
    // Regenerate the index file
    await updateIndexFile(resultsDir);
    console.log("‚úÖ Template index updated successfully");
    
    // If serve flag is set or open dashboard flag is set, start the server
    if (serveFlag || openDashboardFlag) {
      try {
        // Handle serving the dashboard
        if (openDashboardFlag) {
          // Start server and open the dashboard in the browser
          // Always open the specific dashboard path for the analysis
          const serverInfo = await openDashboard(dashboardPath, port);
          console.log(`üöÄ Dashboard opened at: ${serverInfo.url}`);
          console.log(`üîç Analyzing template: ${repoUrl}`);
          
          // Keep the server running until the user presses Ctrl+C
          console.log("\nüëÄ Press Ctrl+C to stop the server and exit");
        } else {
          // Just serve the dashboard without opening
          const serverInfo = await serveDashboard(dashboardPath, port);
          console.log(`üöÄ Dashboard available at: ${serverInfo.url}`);
          console.log("\nüëÄ Press Ctrl+C to stop the server and exit");
        }
      } catch (err) {
        console.error("‚ùå Failed to start dashboard server:", err instanceof Error ? err.message : err);
        // Still show file path as fallback but suggest using server
        console.log(`üìÑ Dashboard file located at: ${dashboardPath}`);
        console.log(`üí° Try again with --serve or --open-dashboard to view in a browser at http://localhost:${port}`);
      }
    } else {
      // Suggest using the server options instead of the file path
      console.log(`üìÑ Dashboard generated at: ${dashboardPath}`);
      console.log(`üí° Run with --serve or --open-dashboard to view in a browser at http://localhost:${port}`);
    }
  } catch (err) {
    console.error("‚ùå Analysis failed:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
}

async function createIssueCommand() {
  if (!repoUrl) {
    console.error("‚ùå Missing required argument: --repo=https://github.com/user/repo");
    showHelp();
    return;
  }

  try {
    console.log(`üîç Analyzing repository with rule set: ${ruleSet}`);
    const result = await analyzeTemplate(repoUrl, ruleSet);
    
    await createIssueFromResults(result);
  } catch (err) {
    console.error("‚ùå Failed to create issue:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
}

async function createIssueFromResults(result: any) {
  try {
    console.log("üìù Preparing GitHub issue...");
    
    // Add date in square brackets to title
    const today = new Date();
    const formattedDate = `[${today.toISOString().split('T')[0]}]`;
    const issueTitle = `Template Doctor Analysis: ${result.compliance.summary} ${formattedDate}`;
    
    // Format the issue body with the compliance results and detailed information
    let issueBody = `# Template Doctor Analysis\n\n`;
    issueBody += `Analyzed on: ${new Date(result.timestamp).toLocaleString()}\n\n`;
    issueBody += `## Summary\n\n`;
    issueBody += `- Repository: [${result.repoUrl}](${result.repoUrl})\n`;
    issueBody += `- Rule Set: ${result.ruleSet}\n`;
    issueBody += `- Compliance: ${result.compliance.compliant.find((item: any) => item.category === 'meta')?.details?.percentageCompliant || 0}%\n`;
    issueBody += `- Issues Found: ${result.compliance.issues.length}\n`;
    issueBody += `- Passed Checks: ${result.compliance.compliant.filter((item: any) => item.category !== 'meta').length}\n\n`;
    
    // Add repository information if available
    if (result.repoInfo) {
      issueBody += `## Repository Information\n\n`;
      issueBody += `- Name: ${result.repoInfo.name || 'Unknown'}\n`;
      if (result.repoInfo.description) {
        issueBody += `- Description: ${result.repoInfo.description}\n`;
      }
      if (result.repoInfo.defaultBranch) {
        issueBody += `- Default Branch: ${result.repoInfo.defaultBranch}\n`;
      }
      issueBody += `\n`;
    }
    
    if (result.compliance.issues.length > 0) {
      issueBody += `## Issues to Fix\n\n`;
      result.compliance.issues.forEach((issue: any, index: number) => {
        issueBody += `### ${index + 1}. ${issue.message}\n\n`;
        
        // Add error details if available
        if (issue.error) {
          issueBody += `**Error Details:**\n\`\`\`\n${issue.error}\n\`\`\`\n\n`;
        }
        
        // Add more context based on issue type
        if (issue.id) {
          issueBody += `**Issue ID:** \`${issue.id}\`\n\n`;
        }
        
        if (issue.category) {
          issueBody += `**Category:** ${issue.category}\n\n`;
        }
        
        // Add remediation steps based on issue type
        issueBody += `**How to Fix:**\n`;
        
        if (issue.id.includes('missing-file')) {
          const fileName = issue.message.match(/Missing required file: (.+)/)?.[1] || "file";
          issueBody += `1. Create the missing file \`${fileName}\`\n`;
          issueBody += `2. Ensure it contains the required content/structure\n`;
          issueBody += `3. Commit the file to the repository\n\n`;
        } 
        else if (issue.id.includes('missing-folder')) {
          const folderName = issue.message.match(/Missing required folder: (.+)/)?.[1] || "folder";
          issueBody += `1. Create the directory structure for \`${folderName}\`\n`;
          issueBody += `2. Add appropriate files within this directory\n`;
          issueBody += `3. Commit the changes to the repository\n\n`;
        }
        else if (issue.id.includes('missing-workflow')) {
          const workflowName = issue.id.replace('missing-workflow-', '');
          issueBody += `1. Create a GitHub Actions workflow file for \`${workflowName}\`\n`;
          issueBody += `2. Ensure it follows the required structure and triggers\n`;
          issueBody += `3. Save it in the \`.github/workflows/\` directory\n`;
          issueBody += `4. Commit the file to the repository\n\n`;
        }
        else if (issue.id.includes('invalid-') || issue.id.includes('malformed-')) {
          issueBody += `1. Review the file content and fix any syntax or formatting errors\n`;
          issueBody += `2. Ensure it follows the required structure and schema\n`;
          issueBody += `3. Validate the file before committing\n`;
          issueBody += `4. Commit the changes to the repository\n\n`;
        }
        else {
          issueBody += `1. Review the issue details carefully\n`;
          issueBody += `2. Make the necessary changes to address the specific compliance issue\n`;
          issueBody += `3. Verify that the changes resolve the issue\n`;
          issueBody += `4. Commit the changes to the repository\n\n`;
        }
      });
      
      // Add general guidance for fixing issues
      issueBody += `## Next Steps\n\n`;
      issueBody += `1. Address each issue individually, starting with the highest priority items\n`;
      issueBody += `2. Run Template Doctor again after making changes to verify improvements\n`;
      issueBody += `3. Aim for 100% compliance to ensure your template follows all best practices\n\n`;
    }
    
    // Add passed checks for context
    if (result.compliance.compliant.length > 0) {
      issueBody += `## Passed Checks\n\n`;
      result.compliance.compliant.filter((item: any) => item.category !== 'meta').forEach((item: any) => {
        issueBody += `- ‚úÖ ${item.message || item.id}\n`;
      });
      issueBody += `\n`;
    }
    
    // Add unique ID to help identify this issue for updates
    const uniqueId = `template-doctor-${Date.now()}`;
    issueBody += `\n\n<!-- Issue Tracker ID: ${uniqueId} -->`;
    
    // First check for open issues
    let existingMainIssue = null;
    let isReopenedIssue = false;
    
    try {
      // First check open issues with the specific label
      console.log("üîç Checking for existing open issues...");
      const { issues: openIssues } = await getGitHubIssues(
        result.repoUrl, 
        'open',
        ['template-doctor-full-scan'] // Filter by this label to improve efficiency
      );
      
      // Look for Template Doctor Analysis issues
      existingMainIssue = openIssues.find(issue => 
        issue.title.startsWith('Template Doctor Analysis:')
      );
      
      // If no open issue found, check closed issues
      if (!existingMainIssue) {
        console.log("üîç Checking for existing closed issues...");
        const { issues: closedIssues } = await getGitHubIssues(
          result.repoUrl, 
          'closed',
          ['template-doctor-full-scan'] // Filter by this label to improve efficiency
        );
        
        existingMainIssue = closedIssues.find(issue => 
          issue.title.startsWith('Template Doctor Analysis:')
        );
        
        if (existingMainIssue) {
          console.log(`üìé Found existing closed Template Doctor issue #${existingMainIssue.number}, reopening...`);
          isReopenedIssue = true;
        }
      } else {
        console.log(`üìé Found existing open Template Doctor issue #${existingMainIssue.number}, updating...`);
      }
      
    } catch (error) {
      // If we fail to check for existing issues, proceed with creating a new one
      console.warn("‚ö†Ô∏è Failed to check for existing issues, creating new issue instead");
    }
    
    // Handle existing issue or create a new one
    let response;
    
    if (existingMainIssue) {
      // Update the existing issue
      response = await updateGitHubIssue(
        result.repoUrl, 
        existingMainIssue.number, 
        issueTitle, 
        issueBody,
        isReopenedIssue, // reopen if it was closed
        "copilot-swe-agent" // assign to Copilot using the correct login name
      );
      
      const actionText = isReopenedIssue ? "reopened and updated" : "updated";
      console.log(`‚úÖ GitHub issue ${actionText}: ${response.html_url}`);
      console.log(`   Issue number: #${response.number}`);
    } else {
      console.log("‚ú® Creating new GitHub issue...");
      // Create a new issue with the template-doctor-full-scan label
      response = await createGitHubIssue(
        result.repoUrl, 
        issueTitle, 
        issueBody,
        ["template-doctor-full-scan"], // Use the correct label for the main issue
        false, // Don't need to check for duplicates again
        "copilot-swe-agent" // assign to Copilot using the correct login name
      );
      
      console.log(`‚úÖ GitHub issue created: ${response.html_url}`);
      console.log(`   Issue number: #${response.number}`);
    }
    
    return response;
  } catch (err) {
    console.error("‚ùå Failed to create GitHub issue:", err instanceof Error ? err.message : err);
    throw err;
  }
}

async function provisionCommand() {
  if (!repoUrl) {
    console.error("‚ùå Missing required argument: --repo=https://github.com/user/repo");
    showHelp();
    return;
  }

  const envArg = args.find(a => a.startsWith("--env="));
  const environment = envArg ? envArg.split("=")[1] : "dev";

  try {
    console.log(`üöÄ Starting AZD provision test for ${repoUrl} (environment: ${environment})...`);
    
    const response = await testAzdProvision(repoUrl, environment);
    console.log(`‚úÖ AZD provision job started. Run ID: ${response.runId}`);
    console.log(`   Use 'template-doctor status --job-id=${response.runId}' to check the status.`);
    
    return response;
  } catch (err) {
    console.error("‚ùå Failed to start AZD provision test:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
}

async function statusCommand() {
  const jobIdArg = args.find(a => a.startsWith("--job-id="));
  const jobId = jobIdArg?.split("=")[1];

  if (!jobId) {
    console.error("‚ùå Missing required argument: --job-id=<id>");
    showHelp();
    return;
  }

  try {
    console.log(`üîç Checking status of job: ${jobId}...`);
    
    const status = await getAzdProvisionStatus(jobId);
    console.log(`Status: ${status.status.toUpperCase()}`);
    
    if (status.progress) {
      console.log(`Progress: ${status.progress}`);
    }
    
    if (status.success !== undefined) {
      console.log(`Success: ${status.success ? 'Yes' : 'No'}`);
    }
    
    if (status.logs) {
      console.log("\nLogs:");
      console.log(status.logs);
    }
    
    if (status.error) {
      console.error("\nError:", status.error);
    }
    
    return status;
  } catch (err) {
    console.error("‚ùå Failed to get job status:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
}

/**
 * Command to list all templates and open the template index dashboard
 */
async function listCommand() {
  try {
    const resultsDir = path.resolve("results");
    if (!existsSync(resultsDir)) {
      console.error("‚ùå No results directory found. Run an analysis first with 'template-doctor analyze --repo=<url>')");
      return;
    }

    console.log("üìä Opening template dashboard...");
    
    const indexPath = path.join(resultsDir, "template-index.html");
    
    if (!existsSync(indexPath)) {
      console.error("‚ùå No template index found. Run an analysis first with 'template-doctor analyze --repo=<url>'");
      return;
    }
    
    // Serve or open the template index
    try {
      if (openDashboardFlag) {
        const serverInfo = await openDashboard(indexPath, port);
        console.log(`üöÄ Template index opened at: ${serverInfo.url}`);
        console.log("\nüëÄ Press Ctrl+C to stop the server and exit");
      } else if (serveFlag) {
        const serverInfo = await serveDashboard(indexPath, port);
        console.log(`üöÄ Template index available at: ${serverInfo.url}`);
        console.log("\nüëÄ Press Ctrl+C to stop the server and exit");
      } else {
        // Suggest using the server options instead of the file path
        console.log(`üìÑ Template index generated at: ${indexPath}`);
        console.log(`üí° Run with --serve or --open-dashboard to view in a browser at http://localhost:${port}`);
      }
    } catch (err) {
      console.error("‚ùå Failed to start dashboard server:", err instanceof Error ? err.message : err);
      // Still show file path as fallback but suggest using server
      console.log(`üìÑ Template index file located at: ${indexPath}`);
      console.log(`üí° Try again with --serve or --open-dashboard to view in a browser at http://localhost:${port}`);
    }
  } catch (err) {
    console.error("‚ùå Failed to list templates:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
}

/**
 * Command to rebuild the template index dashboard
 */
async function rebuildCommand() {
  try {
    const resultsDir = path.resolve("results");
    if (!existsSync(resultsDir)) {
      console.error("‚ùå No results directory found. Run an analysis first with 'template-doctor analyze --repo=<url>')");
      return;
    }

    console.log("üîÑ Rebuilding template index dashboard...");
    
    // Import the updateIndexFile function from dashboardGenerator
    const { updateIndexFile } = await import("./dashboardGenerator.js");
    
    // Regenerate the index file
    await updateIndexFile(resultsDir);
    
    console.log("‚úÖ Template index dashboard rebuilt successfully.");

    const indexPath = path.join(resultsDir, "template-index.html");
    
    if (!existsSync(indexPath)) {
      console.error("‚ùå Failed to create template index.");
      return;
    }

    // Serve or open the template index
    try {
      if (openDashboardFlag) {
        const serverInfo = await openDashboard(indexPath, port);
        console.log(`üöÄ Template index opened at: ${serverInfo.url}`);
        console.log("\nüëÄ Press Ctrl+C to stop the server and exit");
      } else if (serveFlag) {
        const serverInfo = await serveDashboard(indexPath, port);
        console.log(`üöÄ Template index available at: ${serverInfo.url}`);
        console.log("\nüëÄ Press Ctrl+C to stop the server and exit");
      } else {
        // Suggest using the server options instead of the file path
        console.log(`üìÑ Template index generated at: ${indexPath}`);
        console.log(`üí° Run with --serve or --open-dashboard to view in a browser at http://localhost:${port}`);
      }
    } catch (err) {
      console.error("‚ùå Failed to start dashboard server:", err instanceof Error ? err.message : err);
      // Still show file path as fallback but suggest using server
      console.log(`üìÑ Template index file located at: ${indexPath}`);
      console.log(`üí° Try again with --serve or --open-dashboard to view in a browser at http://localhost:${port}`);
    }
  } catch (err) {
    console.error("‚ùå Failed to rebuild template index:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
}

// Run the CLI
run().catch(err => {
  console.error("‚ùå Unexpected error:", err instanceof Error ? err.message : err);
  process.exit(1);
});
